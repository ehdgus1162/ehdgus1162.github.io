---
title: 01. Building Abstractions with Procedures
date: 2025-04-29 11:56:29 +0900
categories: 
  - Computer Science
    - Programming Languages
      - Functional Programming
tags: [Lisp, SICP, Programming, Abstraction, Functional Programming, Computer Science, Scheme, MIT]
toc: true
---

# 01. Building Abstractions with Procedures

※ 이 문서는 Harold Abelson & Gerald Jay Sussman의 Structure and Interpretation of Computer Programs (MIT Press)의 일부 내용을 인용 및 번역한 것으로,
영어 학습 및 컴퓨터 과학 개념 이해를 위한 개인 학습용 해설 자료입니다.
원문에 대한 저작권은 MIT Press에 있으며, 상업적 목적 없이 작성되었습니다.

> 📘 **Educational Notice**  
> This content contains translated and summarized excerpts from  
> *Structure and Interpretation of Computer Programs* by Abelson & Sussman (MIT Press).  
> ✍️ It was created solely for **English language learning** and **computer science education**.  
> ⚠️ Non-commercial use only. All copyrights belong to MIT Press.  
> 📖 The original full text is available at [MIT Official Site](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html).

---
마음이 단순한 관념에 대해 그 힘을 발휘하는 작용은 주로 세 가지이다. 

1. 여러 단순한 관념을 하나의 복합 관념으로 결합하는 것, 그리고 이로써 모든 복합 관념이 만들어진다. 
2. 두 번째는 두 개의 관념(단순하든 복합적이든)을 함께 가져와서, 그것들을 서로 옆에 두고 하나로 합치지 않은 채 동시에 바라보는 것이다. 이를 통해 정신은 모든 '관계'에 대한 관념을 얻게 된다.
3. 세 번째는 그것들을 실제 존재 속에서 함께 따라다니는 다른 모든 관념들로부터 분리하는 것이다. 이것은 '추상화'라고 불리며, 이렇게 해서 정신의 모든 일반 관념이 만들어진다.

 우리는 이제 막 계산 과정이라는 개념을 공부하려고 한다. 
계산 과정은 컴퓨터 속에 존재하는 추상적인 존재들이다.
프로세스는 발전해 가면서 _'데이터'_ 라고 불리는 다른 추상적인 것들을 조작한다. 프로세스의 진화는 _'프로그램'_ 이라고 불리는 규칙들의 패턴에 의해 인도된다. 사람들은 프로세스를 지시하기 위해 프로그램을 만든다. 사실상 우리는 우리의 주문으로 컴퓨터의 정령을 불러내는 것이다.

하나의 계산 과정은 정말로 마법사가 생각하는 영혼의 개념과 매우 비슷하다. 그것을 볼 수도 없고 만질 수도 없다. 그것은 전혀 물질로 이루어져 있지 않다.
그러나 그것은 매우 실제하는 존재이다. 그것은 지적인 작업을 수행할 수 있으며, 질문에 대답할 수도 있다.
그것은 은행에서 돈을 지불하거나, 공장에서 로봇 팔을 제어함으로써 세상에 영향을 미칠 수 있다. 우리가 프로세스를 불러내기 위해 사용하는 프로그램들은 마법사의 주문과 같다.
그것들은 우리의 프로세스가 수행하기를 원하는 작업들을 지시하는, 신비롭고 난해한 프로그래밍 언어로 작성된 기호적 표현들로부터 신중하게 구성된다.

제대로 작동하는 컴퓨터에서는 계산 과정이 프로그램을 정확하고 정밀하게 실행한다.
따라서 마법 견습생들처럼, 초보 프로그래머들은 자신들의 주문이 불러올 결과를 이해하고 예측하는 법을 반드시 배워야 한다.
프로그램 안의 아주 작은 오류조차도 (보통 '버그'나 '글리치'라고 불리는) 복잡하고 예상치 못한 결과를 초래할 수 있다.

다행히도, 프로그래밍을 배우는 것은 마법을 배우는 것보다 훨씬 덜 위험하다. 왜냐하면 우리가 다루는 정령들은 편리하고 안전한 방식으로 통제되어 있기 때문이다.
그러나 실제 세계의 프로그래밍은 주의, 전문성, 그리고 지혜를 요구한다. 예를 들어 컴퓨터 지원 설계 프로그램 안의 작은 버그 하나가 비행기나 댐의 치명적인 붕괴, 또는 산업용 로봇의 자기 파괴로 이어질 수 있다. 리스프는 수학적 형식 체계로 시작되었음에도 불구하고, 실용적인 프로그래밍 언어이다. 리스프 인터프리터는 리스프 언어로 기술된 과정을 수행하는 기계이다.

숙련된 소프트웨어 엔지니어들은 결과로 만들어진 프로세스가 의도한 작업을 수행할 것임을 합리적으로 확신할 수 있도록 프로그램을 조직하는 능력을 갖추고 있다.
그들은 자신의 시스템이 어떻게 동작할지를 사전에 그려볼 수 있다. 그들은 예상치 못한 문제가 치명적인 결과로 이어지지 않도록 프로그램을 구조화하는 방법을 알고 있으며, 문제가 실제로 발생했을 때 프로그램을 디버깅할 수도 있다.
잘 설계된 계산 시스템은, 잘 설계된 자동차나 원자로처럼, 모듈식 방식으로 설계된다. 이렇게 함으로써 부품들을 개별적으로 만들고, 교체하고, 디버깅할 수 있다.

[Programming in Lisp](https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-4.html#%_toc_%_sec_Temp_6)

우리는 계산 과정을 설명하기 위한 적절한 언어가 필요하며, 이 목적을 통해 프로그래밍 언어 리스프<sup>Lisp</sup> 를 사용할 것이다.
우리가 일상적인 생각을 영어, 프랑스어, 일본어 같은 자연어로 표현하듯이, 그리고 수학적인 현상은 수학 기호로 표현하듯이, 우리의 절차적인 사고는 Lisp로 표현될 것이다.
리스프는 1950년대 후반, 재귀 방정식이라 불리는 특정한 종류의 논리 표현식의 사용에 대해 사고하고자 하는 형식 체계이자 계산 모델로서 발명되었다.
이 언어는 존 매카시에 의해 고안되었으며, 그의 논문 「기호 표현식의 재귀 함수와 기계에 의한 그 계산」(McCarthy, 1960)에 기반하고 있다.

리스프는 수학적 형식 체계로 시작되었음에도 불구하고, 실용적인 프로그래밍 언어이다. 리스프 인터프리터는 리스프 언어로 기술된 과정을 수행하는 기계이다.
최초의 리스프 인터프리터는 메카시가 MIT 전자공학 연구소의 인공지능 그룹과 MIT 계산 센터 소속 동료들과 학생들의 도움을 받아 구현되었다.
Lisp는 'LISt Processing'의 약어로, 대수 표현식의 기호적 미분과 적분과 같은 프로그래밍 문제를 해결하기 위해 기호 조작 기능을 제공하도록 설계되었다.

수학적 형식 체계로 시작된 리스프는 시간이 지나며 실용적인 프로그래밍 언어로 발전했다. 매카시와 MIT 전자공학 연구소 팀에 의해 최초로 구현된 리스프 인터프리터는 이 언어로 기술된 과정을 수행하는 기계로 작동한다.
다른 언어들과의 뚜렷한 차별점은 ATOM과 List라는 새로운 개념을 데이터의 기본 단위로 도입한 점에 있다. 이 혁신적인 언어는 처음부터 치밀하게 설계된 것이 아니라, 사용자의 요구와 다양한 실험적 시도 속에서 자연스럽게 진화해 왔다.
고정된 설계도 없이 발전해 온 이 언어의 사용자 커뮤니티는 자유로운 발전을 위해 "공식화"를 의도적으로 거부해왔다. 오랜 역사에도 불구하고, 초기 설계의 유연성과 우아함, 그리고 지속적인 진화 덕분에 Lisp는 가장 최신의 프로그래밍 설계 개념까지 받아들이며 살아남았다.
그 결과 현재의 Lisp는 원래의 대부분 특징을 공유하면서도 중요한 방식에서 서로 다를 수 있는 여러 방언들의 집합이 되었다. 이 책에서 사용되는 리스프의 방언은 '스킴(Scheme)'이라고 불린다.

리스프는 그 실험적인 특성과 기호 조작에 대한 강조 때문에, 적어도 포트란과 비교했을 때 처음에는 수치 계산에 대해 매우 비효율적이었다.
그러나 수년에 걸쳐, 수치 계산을 상당히 효율적으로 수행할 수 있는 기계어로 프로그램을 변환하는 리스프 컴파일러들이 개발되어 왔다.
그리고 특수한 응용 분야에서는 리스프가 매우 효과적으로 사용되어 왔다. 비록 리스프가 극도로 비효율적이라는 과거의 평판을 아직 완전히 극복하지는 못했지만, 현재는 효율성이 핵심 관심사가 아닌 많은 응용 분야에서 사용되고 있다.
예를 들어, 리스프는 운영 체제의 셸 언어나, 편집기 및 컴퓨터 지원 설계(CAD) 시스템을 위한 확장 언어로 선호되는 언어가 되었다.

리스프가 주류 언어가 아니라면, 우리는 왜 프로그래밍 논의의 틀로 그것을 사용하는가? 그것은 이 언어가 고유한 특징을 가지고 있어, 중요한 프로그래밍 구조들과 데이터 구조들을 공부하고, 그것들을 뒷받침하는 언어적 특성과 연결짓는 데에 훌륭한 매체가 되기 때문이다.
이러한 특징들 중 가장 중요한 것은, 프로시저라고 불리는 프로세스에 대한 리스프 표현이 리스프 데이터로서 스스로 표현되고 조작될 수 있다는 사실이다. 이것이 중요한 이유는, '수동적' 데이터와 '능동적' 프로세스 사이의 전통적인 구분을 흐릿하게 만드는 능력에 기반한 강력한 프로그램 설계 기법들이 존재하기 때문이다.

우리가 앞으로 알게 되겠지만, 프로시저를 데이터처럼 다루는 리스프의 유연성은 리스프를 이러한 기법들을 탐구하는 데 있어 지금까지 존재하는 언어들 중 가장 편리한 언어 중 하나로 만든다.
프로시저를 데이터로 표현할 수 있는 능력은, 다른 프로그램을 데이터처럼 조작해야 하는 프로그램(예를 들어 컴퓨터 언어를 지원하는 인터프리터나 컴파일러 등)을 작성하는 데에 리스프를 훌륭한 언어로 만든다. 이러한 점들을 넘어서서, 리스프로 프로그래밍하는 것은 정말 재미있다!

---
