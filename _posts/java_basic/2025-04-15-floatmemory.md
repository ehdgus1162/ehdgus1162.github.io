---
title: 자바에서 부동소수점(float)의 메모리 저장 원리
date: 2025-04-15 17:05:49 +0900
categories: [Java]
tags: [Java, basic, floating-point, IEEE-754, data-type]
toc: true
permalink: /posts/java/:title/
---

# 부동소수점의 개념과 계산

자바는 IEEE 754 표준에 근거해 float 타입과 double 타입의 값을 부동 소수점(floating-point) 방식으로 메모리에 저장합니다. 이번 글에서는 부동소수점이 메모리에 어떻게 저장되는지 그 원리를 알아보겠습니다.

## 1. 부동소수점이란?

부동소수점(Floating-point)이란 소수점 위치가 숫자마다 바뀜(필요에 따라 조정됨)을 의미합니다. 이 방식은 매우 큰 수부터 매우 작은 수까지 다양한 크기의 실수를 효율적으로 표현할 수 있습니다.

예를 들어, 같은 비트 수로 다음과 같은 다양한 크기의 숫자들을 표현할 수 있습니다:
- 매우 작은 수: 0.000000000123
- 일반적인 수: 123.456
- 매우 큰 수: 1.23 × 10^38

이것이 가능한 이유는 소수점의 위치를 고정하지 않고 "부동"(floating)하기 때문입니다.

## 2. 부동소수점의 구성 요소

부동소수점은 다음 세 가지 구성 요소로 이루어집니다:

| 구성 요소 | 의미 |
|----------|------|
| 부호 비트 | 양수/음수 (0: 양수, 1: 음수) |
| 지수 (exponent) | 소수점 위치를 조정하는 값 (몇 승인지?) |
| 가수 (mantissa) | 실제 숫자의 유효 숫자 |

부동소수점은 과학적 표기법과 유사하게 다음과 같이 표현됩니다:

실수 = (-1)^부호 × 1.가수 × 2^지수




## 3. 자바에서 부동소수점 저장 방식

자바의 float 타입과 double 타입은 IEEE 754 표준에 따라 다음과 같이 메모리에 저장됩니다:

| 타입 | 저장 방식 | 비트 수 | 범위 |
|------|-----------|---------|------|
| float | 부호 1 + 지수 8 + 가수 23 | 32비트 | 약 ±3.4 × 10^38 |
| double | 부호 1 + 지수 11 + 가수 52 | 64비트 | 약 ±1.8 × 10^308 |

## 4. 부동소수점의 메모리 저장 과정 (예: 6.5)

`6.5`(10진수)를 float에 저장하는 과정을 단계별로 살펴보겠습니다.

### 4.1 부호 결정
- 양수이므로 `부호 비트 = 0`

### 4.2 2진수로 변환
- 정수 부분: 6 → 110 (2진수)
  - 6 ÷ 2 = 3 (나머지 0)
  - 3 ÷ 2 = 1 (나머지 1)
  - 1 ÷ 2 = 0 (나머지 1)
  - 아래에서 위로 읽으면: 110
  
- 소수 부분: 0.5 → .1 (2진수)
  - 0.5 × 2 = 1.0 (정수부 1)
  - 정수부만 모으면: .1
  
- 결과: `6.5 = 110.1` (2진수)

### 4.3 정규화 (Normalization)
- 2진수 과학적 표기법으로 변환(소수점을 첫 번째 1 뒤로 이동)
- `110.1 = 1.101 × 2^2`
- 이때 소수점이 오른쪽으로 2칸 이동했으므로 지수는 2
- 정규화된 가수: `1.101`에서 앞의 1은 항상 존재하므로 저장하지 않음(hidden bit)
- 실제 저장되는 가수: `101`

### 4.4 지수 계산 (Bias 적용)
- float의 지수부는 8비트이며, bias 값은 127
- 실제 지수 값(2)에 bias를 더함: `2 + 127 = 129`
- 129를 2진수로 변환: `10000001`
- 이 값이 8비트 지수부에 저장됨

### 4.5 가수 저장
- 가수 `101`을 23비트로 확장(남은 부분은 0으로 채움)
- `10100000000000000000000`

### 4.6 최종 메모리 구성 (32비트 float)
```
[ 부호 ] [   지수    ] [           가수           ]
   0     10000001      10100000000000000000000
```

### 4.7 16진수 표현
이 32비트 값을 16진수로 변환하면:
```
0 10000001 10100000000000000000000
= 0100 0000 1101 0000 0000 0000 0000 0000
= 0x40D00000
```

### 4.8 값 검증
저장된 부동소수점 값을 다시 실수로 변환해보면:
```
실수 = (-1)^0 × 1.101 × 2^(129-127)
    = 1 × 1.101 × 2^2
    = 1.101 × 4
    = (1 + 0.5 + 0.125) × 4
    = 1.625 × 4
    = 6.5
```

## 5. 부동소수점 저장 방식의 이해를 위한 비트 계산

각 비트가 어떤 값을 나타내는지 알면 부동소수점을 더 잘 이해할 수 있습니다:

| 비트 | 위치 | 값 (2의 n승) | 계산 | 결과 |
|------|------|--------------|------|------|
| 1 | 2⁰ | 1 | 1 × 1 |  +1 |
| .1 | 2⁻¹ | 0.5 | 1 × 0.5 |  +0.5 |
| .0 | 2⁻² | 0.25 | 0 × 0.25 | 0 |
| .1 | 2⁻³ | 0.125 | 1 × 0.125 |  +0.125 |

따라서 1.101(2) = 1 + 0.5 + 0.125 = 1.625(10)

## 6. 부동소수점의 한계와 정밀도 문제

10진수 실수 중 일부는 2진수로 정확히 표현할 수 없어 근사치로 저장됩니다.

### 6.1 순환소수 문제
예를 들어, 0.1(10진수)은 2진수로 표현하면 무한히 반복되는 순환소수가 됩니다:
```
0.1(10) = 0.0001100110011...(2) (무한 반복)
```

### 6.2 정밀도 오차 예시
이러한 이유로 자바에서 다음과 같은 현상이 발생합니다:
```java
System.out.println(0.1f); // 출력: 0.1
System.out.println(0.1f + 0.1f + 0.1f); // 출력: 0.30000000000000004 (정확히 0.3이 아님)

float f = 0.1f;
System.out.println(f == 0.1); // 출력: false
```

### 6.3 정밀도 표현 한계
float와 double이 실제로 저장하는 근사값:
```
0.1(10진수) 저장 시:
- float 저장값:  약 0.10000000149011612
- double 저장값: 약 0.10000000000000000555...
```

> 참고: 정밀한 십진 소수점 계산이 필요한 경우(특히 금융 계산 등)에는 `BigDecimal` 클래스를 사용하는 것이 바람직합니다. BigDecimal의 사용법은 다음 글에서 다루겠습니다.

## 7. 결론

부동소수점은 제한된 비트로 매우 넓은 범위의 실수를 표현할 수 있게 해주는 효율적인 방식입니다. 하지만 모든 십진 실수를 정확히 표현할 수는 없다는 한계가 있습니다. 

자바 개발자라면 이러한 부동소수점의 특성을 이해하고, 필요에 따라 적절한 데이터 타입(float, double, BigDecimal)을 선택하는 것이 중요합니다.