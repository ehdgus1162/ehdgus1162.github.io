---
title: 이진수 계산과 변환
date: 2025-04-15 17:10:00 +0900
categories: [Computer Science]
tags: [binary, number-system, conversion, computer-basics]
toc: true
---

# 이진수 계산과 변환

컴퓨터는 모든 데이터를 0과 1로 이루어진 이진수(binary number)로 처리합니다. 이진수 체계를 이해하면 컴퓨터가 숫자, 문자, 이미지 등의 데이터를 저장하고 처리하는 근본적인 방식을 이해할 수 있습니다.

## 1. 10진수를 2진수로 변환하기

10진수를 2진수로 변환하는 과정은 정수 부분과 소수 부분에 따라 다른 방법을 사용합니다.

### 1.1 정수 부분 변환

**방법**: 2로 계속 나누고, 나머지를 아래에서 위로 거꾸로 읽습니다.

**예시**: 6을 2진수로 변환
```
6 ÷ 2 = 3 ... 0 (나머지)
3 ÷ 2 = 1 ... 1 (나머지)
1 ÷ 2 = 0 ... 1 (나머지)
→ 아래에서 위로 읽으면 → 110

따라서 6(10진수) = 110(2진수)
```

**예시**: 25를 2진수로 변환
```
25 ÷ 2 = 12 ... 1 (나머지)
12 ÷ 2 = 6  ... 0 (나머지)
6  ÷ 2 = 3  ... 0 (나머지)
3  ÷ 2 = 1  ... 1 (나머지)
1  ÷ 2 = 0  ... 1 (나머지)
→ 아래에서 위로 읽으면 → 11001

따라서 25(10진수) = 11001(2진수)
```

### 1.2 소수 부분 변환

**방법**: 소수 부분에 2를 곱하고, 정수 부분을 순서대로 나열합니다.

**예시**: 0.625를 2진수로 변환
```
0.625 × 2 = 1.25   → 정수 부분 1, 소수 부분 0.25 남음
0.25  × 2 = 0.5    → 정수 부분 0, 소수 부분 0.5 남음
0.5   × 2 = 1.0    → 정수 부분 1, 소수 부분 0 남음 (종료)
→ 정수 부분을 순서대로 나열 → 0.101(2진수)

따라서 0.625(10진수) = 0.101(2진수)
```

**예시**: 0.4를 2진수로 변환
```
0.4 × 2 = 0.8     → 정수 부분 0, 소수 부분 0.8 남음
0.8 × 2 = 1.6     → 정수 부분 1, 소수 부분 0.6 남음
0.6 × 2 = 1.2     → 정수 부분 1, 소수 부분 0.2 남음
0.2 × 2 = 0.4     → 정수 부분 0, 소수 부분 0.4 남음
... (0.4가 다시 나타나 위 과정이 무한 반복됨)
→ 0.01100110011...(무한 반복)

따라서 0.4(10진수) = 0.0110011001...(2진수로 무한 반복)
```

| 구분 | 변환 방법 | 특징 |
|------|-----------|------|
| 정수 | 2로 나누고 나머지를 아래에서 위로 읽기 | 항상 유한한 자릿수로 표현 가능 |
| 소수 | 2를 곱하고 정수 부분만 순서대로 모으기 | 일부 소수는 무한 반복됨 |

> **주의**: 10진수의 일부 소수(예: 0.1, 0.2, 0.3 등)는 2진수로 정확히 표현할 수 없고 무한히 반복되는 소수가 됩니다. 이로 인해 컴퓨터에서 실수 계산 시 작은 오차가 발생할 수 있습니다.

## 2. 2진수를 10진수로 변환하기

2진수를 10진수로 변환하는 방법은 각 자리의 가중치(2의 거듭제곱)를 계산하여 더하는 방식입니다.

### 2.1 정수 부분 변환

각 자리의 값에 2의 거듭제곱을 곱하여 합산합니다.

**예시**: 101101을 10진수로 변환
```
1 × 2^5 + 0 × 2^4 + 1 × 2^3 + 1 × 2^2 + 0 × 2^1 + 1 × 2^0
= 32 + 0 + 8 + 4 + 0 + 1
= 45

따라서 101101(2진수) = 45(10진수)
```

좀 더 이해하기 쉽게 표로 표현하면:

| 자릿수 위치 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
|------------|-----|-----|-----|-----|-----|-----|
| 자릿수 값   | 32  | 16  | 8   | 4   | 2   | 1   |
| 이진수 숫자 | 1   | 0   | 1   | 1   | 0   | 1   |
| 계산       | 32  | 0   | 8   | 4   | 0   | 1   |

합계: 32 + 0 + 8 + 4 + 0 + 1 = 45

### 2.2 소수 부분 변환

소수점 이하 자리에서는 2의 음수 거듭제곱을 곱합니다.

**예시**: 0.101을 10진수로 변환
```
1 × 2^(-1) + 0 × 2^(-2) + 1 × 2^(-3)
= 0.5 + 0 + 0.125
= 0.625

따라서 0.101(2진수) = 0.625(10진수)
```

표로 표현하면:

| 자릿수 위치 | 2^(-1) | 2^(-2) | 2^(-3) |
|------------|--------|--------|--------|
| 자릿수 값   | 0.5    | 0.25   | 0.125  |
| 이진수 숫자 | 1      | 0      | 1      |
| 계산       | 0.5    | 0      | 0.125  |

합계: 0.5 + 0 + 0.125 = 0.625

## 3. 다양한 숫자 체계 변환

### 3.1 8진수(Octal)와 16진수(Hexadecimal)

컴퓨터 과학에서는 2진수 외에도 8진수(0-7)와 16진수(0-9, A-F)를 자주 사용합니다.

| 숫자 체계 | 기호 | 사용 예시 | 변환 편의성 |
|----------|------|----------|------------|
| 2진수 | 0, 1 | 1010 | 컴퓨터의 기본 단위 |
| 8진수 | 0-7 | 0127 (앞에 0을 붙임) | 2진수 3자리 = 8진수 1자리 |
| 10진수 | 0-9 | 42 | 일상적인 계산 체계 |
| 16진수 | 0-9, A-F | 0x2A (앞에 0x를 붙임) | 2진수 4자리 = 16진수 1자리 |

### 3.2 2진수 <-> 8진수, 16진수 변환

**2진수 -> 8진수 변환**: 2진수를 오른쪽부터 3자리씩 그룹화하여 8진수로 변환

```
2진수: 1 010 111
8진수:   1   2   7   -> 127
```

**2진수 -> 16진수 변환**: 2진수를 오른쪽부터 4자리씩 그룹화하여 16진수로 변환

```
2진수: 0010 1010
16진수:   2    A    -> 0x2A
```

**16진수 -> 2진수 변환**: 각 16진수 자리를 4비트 2진수로 변환

```
16진수: A    F
2진수:  1010 1111  -> 10101111
```

## 4. 음수의 2진수 표현: 2의 보수법

컴퓨터에서 음수는 2의 보수(two's complement) 방식으로 표현합니다. 이 방식을 사용하면 덧셈 회로만으로 뺄셈을 구현할 수 있어 하드웨어 설계가 간단해집니다.

### 4.1 2의 보수 구하는 방법

1. 원래 수의 모든 비트를 반전시킵니다(0→1, 1→0). 이를 1의 보수라고 합니다.
2. 1의 보수에 1을 더합니다. 이것이 2의 보수입니다.

**예시**: byte 타입(8비트)에서 -10의 표현
```
10의 이진수:    00001010
비트 반전:      11110101  (1의 보수)
1 더하기:       11110110  (2의 보수)

따라서 -10의 2진수 표현은 11110110입니다.
```

### 4.2 2의 보수 표현의 장점

2의 보수 표현에서는 최상위 비트(MSB)가 1이면 음수, 0이면 양수를 의미합니다. 2의 보수를 사용하는 이유는 다음과 같습니다:

1. **0의 유일한 표현**: 1의 보수를 사용하면 +0과 -0이 구분되지만, 2의 보수에서는 0이 유일하게 표현됩니다.

2. **덧셈과 뺄셈의 통합**: A - B는 A + (-B)로 계산할 수 있어 하드웨어가 단순해집니다.

**예시**: 10 - 7을 2의 보수로 계산
```
10의 이진수:     00001010
-7의 2의 보수:   11111001 (7의 2의 보수)
덧셈 결과:       00000011 (= 3)
```

1의 보수만 사용하면 덧셈 시 문제가 발생합니다. 예를 들어 10과 -10의 덧셈:

```
   00001010   (10)
+  11110101   (1의 보수로 표현한 -10)
--------------
   11111111   (결과: -0)
```

이는 -0이 되어 0의 표현이 두 가지(+0과 -0)가 됩니다. 2의 보수에서는:

```
   00001010   (10)
+  11110110   (2의 보수로 표현한 -10)
--------------
(1)00000000   (맨 앞의 자리올림은 버리고 0이 남음)
```

이처럼 2의 보수를 사용하면 0의 표현이 하나만 존재하고, 덧셈으로 뺄셈을 자연스럽게 구현할 수 있습니다.

### 4.3 2의 보수의 범위

n비트 2의 보수 체계에서 표현 가능한 정수 범위:
- 최소값: -2^(n-1)
- 최대값: 2^(n-1) - 1

**예**: 8비트(1바이트) 시스템에서는 -128 ~ 127까지 표현 가능

## 5. 2진수 연산

### 5.1 2진수 덧셈

10진수 덧셈과 유사하지만, 각 자리에서 1+1=10(2진수)가 됩니다.

```
   1 1   (자리올림)
   1 0 1 1  (11)
+  0 1 0 1  (5)
-----------
   1 1 0 0  (16)
```

### 5.2 2진수 뺄셈

2의 보수를 이용하여 덧셈으로 구현합니다.
```
   1 0 1 1  (11)
-  0 1 0 1  (5)
-----------
   0 1 1 0  (6)
```

이는 `1011 + (~0101 + 1)`로 계산됩니다.

### 5.3 2진수 곱셈

10진수 곱셈과 유사한 방식으로 수행됩니다.

```
      1 0 1    (5)
    × 1 1 0    (6)
    -------
      0 0 0    (0×5)
     1 0 1     (1×5, 왼쪽으로 1칸 이동)
    1 0 1      (1×5, 왼쪽으로 2칸 이동)
    -------
    1 1 1 1 0  (30)
```

### 5.4 2진수 AND, OR, XOR 연산

비트 단위 연산은 컴퓨터 프로그래밍에서 중요한 역할을 합니다.

| 연산 | 기호 | 설명 | 예시 |
|------|------|------|------|
| AND | & | 두 비트가 모두 1이면 1, 아니면 0 | 1010 & 1100 = 1000 |
| OR | \| | 두 비트 중 하나라도 1이면 1, 아니면 0 | 1010 \| 1100 = 1110 |
| XOR | ^ | 두 비트가 다르면 1, 같으면 0 | 1010 ^ 1100 = 0110 |
| NOT | ~ | 비트 반전 (0→1, 1→0) | ~1010 = 0101 (단순화) |


## 6. 결론

이진수는 컴퓨터 과학의 기본 개념이며, 모든 컴퓨터 시스템의 기반이 됩니다. 2진수 체계를 이해하면 컴퓨터가 데이터를 어떻게 저장하고 처리하는지에 대한 근본적인 이해를 얻을 수 있습니다.

