---
title: 1.1 프로그래밍의 기본 요소
date: 2025-04-29 11:56:29 +0900
categories: 
  - Computer Science
    - Programming Languages
      - Functional Programming
tags: [Lisp, SICP, Programming, Abstraction, Functional Programming, Computer Science, Scheme, MIT]
toc: true
---

<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' }
  };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

[Teach Yourself Computer Science](https://teachyourselfcs.com/)

> 📘 **Educational Notice**  
> This content contains translated and summarized excerpts from  
> *Structure and Interpretation of Computer Programs* by Abelson & Sussman (MIT Press).  
> ✍️ It was created solely for **English language learning** and **computer science education**.  
> ⚠️ Non-commercial use only. All copyrights belong to MIT Press.  
> 📖 The original full text is available at [MIT Official Site](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html).




## 1.1 프로그래밍의 기본 요소

강력한 프로그래밍 언어는 단순히 컴퓨터에게 작업을 수행하도록 지시하는 수단에 그치지 않는다. 그것은 또한 우리가 프로세스에 대해 사고를 정리하는 틀로서의 역할을 한다. 

따라서 언어를 설명할 때는, 단순한 생각들을 결합해 더 복잡한 생각을 형성하는 수단에 특별히 주의를 기울여야 한다. 모든 강력한 언어는 이를 달성하기 위해 세 가지 메커니즘을 갖추고 있다:

- **기본 표현식(Primitive Expressions)** → 언어가 다루는 가장 단순한 개체를 나타냄
- **결합 수단(Means of Combination)** → 더 단순한 요소들로부터 복합 요소를 구축함
- **추상화 수단(Means of Abstraction)** → 복합 요소를 하나의 단위로 이름 붙이고 조작할 수 있게 함

프로그래밍에서는 프로시저와 데이터라는 두 종류의 요소를 다룬다. (나중에 우리는 이 둘이 사실 그렇게 뚜렷하게 구별되지 않는다는 것을 알게 될 것이다.) 쉽게 말해:
- 데이터는 우리가 조작하고자 하는 "것"
- 프로시저는 그 데이터를 조작하는 규칙을 설명한 것

따라서 모든 강력한 프로그래밍 언어는 기본 데이터와 기본 프로시저를 설명할 수 있어야 하며, 프로시저와 데이터를 결합하고 추상화하는 방법을 갖추어야 한다.

이 장에서는 프로시저를 만드는 규칙에 집중할 수 있도록 단순한 수치 데이터만 다룰 것이다.[^4] 이후 장들에서는 이 동일한 규칙들이 복합 데이터도 조작할 수 있는 프로시저를 만들 수 있게 해준다는 것을 보게 될 것이다.

---

### 1.1.1 표현식

프로그래밍을 시작하는 쉬운 방법 중 하나는, Lisp의 Scheme 방언을 위한 인터프리터와의 일반적인 상호작용을 살펴보는 것이다. 컴퓨터 터미널 앞에 앉아 있다고 상상해보라. 당신이 하나의 표현식을 입력하면, 인터프리터는 그 표현식을 평가한 결과를 출력하여 응답한다.

당신이 입력할 수 있는 기본 표현식 중 하나는 숫자이다. (좀 더 정확히 말하면, 당신이 입력하는 표현식은 10진법으로 숫자를 나타내는 숫자 문자들로 구성된다.) 486이라는 숫자를 Lisp에 입력하면, 인터프리터는 _486_ 을 출력하여 응답할 것이다. (숫자 표현식은 입력하면 그대로 결과로 출력된다.)

숫자를 나타내는 표현식은, `+`나 `*` 같은 기본 프로시저를 나타내는 표현식과 결합되어, 그 숫자들에 프로시저를 적용하는 것을 나타내는 복합 표현식(compound expression)을 구성할 수 있다. 예를 들면:

```scheme
(+ 137 349)   ; => 486
(- 1000 334)  ; => 666
(* 5 99)      ; => 495
(/ 10 5)      ; => 2
(+ 2.7 10)    ; => 12.7
```

프로시저 적용을 나타내기 위해 괄호로 묶어 표현식 목록을 구분한 이런 표현식들을 **조합(combination)**이라고 부른다.
- 목록에서 가장 왼쪽에 있는 요소는 **연산자(operator)**
- 나머지 요소들은 **피연산자(operand)**라고 함
- 조합의 값은 연산자가 명시한 프로시저를 피연산자들의 값에 적용해 얻음

연산자를 피연산자보다 앞에 두는 관례를 **전위 표기법(prefix notation)**이라고 부른다. 이 표기법은 일반적인 수학 방식과는 꽤 달라서, 처음에는 다소 혼란스러울 수 있다. 하지만 전위 표기법은 몇 가지 장점을 지니고 있다:

1. 임의의 개수만큼 인자를 받을 수 있는 프로시저를 자연스럽게 표현할 수 있음:
```scheme
(+ 21 35 12 7) ; => 75
(* 25 4 12)    ; => 1200
```

2. 모호함이 생기지 않음:
   - 연산자가 항상 맨 앞에 위치
   - 전체 조합이 괄호로 둘러싸여 있음

3. 조합 안에 또 다른 조합을 자연스럽게 중첩할 수 있음:
```scheme
(+ (* 3 5) (- 10 6)) ; => 19
```

이런 중첩의 깊이나, Lisp 인터프리터가 평가할 수 있는 표현식의 전체적인 복잡성에는 이론상 제한이 없다. 오히려, 여전히 비교적 단순한 표현식조차 헷갈리는 것은 우리 인간들이다.

```scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
```

인터프리터는 이 표현식을 손쉽게 평가하여 57이라는 결과를 얻을 수 있다. 우리는 이런 복잡한 표현식을 더 읽기 쉬운 형태로 작성함으로써 스스로 이해를 도울 수 있다:

```scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

긴 조합 표현식을 세로로 정렬된 형태로 표현하는 서식 규칙을 **pretty-printing**이라고 한다. 이 방식에서는 피연산자들을 줄바꿈하고 들여써서 표현식의 구조가 명확하게 드러나도록 한다.

복잡한 표현식이라 하더라도, 인터프리터는 항상 동일한 기본 사이클로 작동한다:
1. 표현식을 입력받고
2. 평가한 뒤
3. 결과를 출력한다

이런 작동 방식은 보통 **read-eval-print loop(REPL)**이라고 불린다. 특히 주목할 점은, 표현식의 값을 출력하라고 따로 지시하지 않아도 된다는 것이다.

#### 개념 이해를 위한 연습문제

지금까지 배운 개념들을 더 잘 이해하고 Scheme 프로그래밍에 익숙해지기 위해 몇 가지 연습문제를 풀어보자.

##### 연습문제 1: 계산 결과 구하기

다음 Scheme 표현식들을 평가하여 결과를 구해보세요:

```scheme
(+ 2 4 6)
(* 3 2 5)
(+ (* 2 3) (- 10 4))
(/ 20 (+ 2 3))
```

##### 연습문제 2: 수식을 Scheme 전위 표기법으로 변환하기

다음 수학식을 **Scheme 전위 표기법**으로 변환해보세요:

1. 
$$
2 \times (3 + 4)
$$

2. 
$$
\frac{(10 - 2)}{(1 + 1)}
$$

3. 
$$
(5 + 6) \times (2 + 3)
$$



##### 연습문제 3: 유효한 조합인지 판단하기

다음 표현식이 유효한 Scheme 조합인지 판단하세요(O/X):

1. `(+ 1 2)`
2. `(* 2 (+ 3 4))`
3. `(1 + 2)`
4. `(+ 2 (* 3))`
5. `(+ (+ 1 2) (+ 3 4))`

##### 연습문제 4: Pretty-printing 연습

다음 표현식을 가독성 좋게 들여쓰기 형태로 다시 작성해보세요:

```scheme
(+ (* 2 (+ 3 4)) (- 10 6))
```

##### 연습문제 5: REPL 사이클 따라가기

인터프리터가 다음 입력을 받았을 때, 어떤 순서로 처리하는지 단계별로 서술해보세요:

```scheme
(+ (* 2 3) (- 8 5))
```

---

이 연습문제들을 통해 Scheme의 표현식 구조와 계산 방식에 대한 직관을 기를 수 있습니다. 다음 섹션으로 넘어가기 전에 이 문제들을 풀어보는 것이 좋습니다.

[^4]: 숫자를 '단순한 데이터'라고 규정하는 것은 뻔뻔한 속임수다. 사실 숫자를 다루는 것은 어떤 프로그래밍 언어에서도 가장 까다롭고 혼란스러운 측면 중 하나이다. 